module control_unit (
//the overall control_unit of the game
    input clk,  // clock
    input rst,  // reset

    input level_in[2], //current level
    output level_out[2], //next level
    
    input start[1], //START button
    input reset[1], //RESET button
    input timer[16], //remaining time 
    
    input map[8][8],
    
    input direction[4], //up down left right
    input x_pos_in[3], //suppose 3 bit for x and y coordinate 0-7
    input y_pos_in[3],
    output x_pos_out[3],
    output y_pos_out[3],

    output werf[1], //todo： write enable for map writing 

    output game_start[1];//todo：selector signal for led mux
    
  ) {
      //sig


    //init
    //preprocess unit for change position to 1 bit decimal
    dff x_temp[3](#INIT(0), .clk(clk), .rst(rst)); //code in decimal
    dff y_temp[3](#INIT(0), .clk(clk), .rst(rst)); //code in decimal
    dff level_temp[2](#INIT(0), .clk(clk), .rst(rst)); //code in decimal
  
    fsm ctrl(.clk(clk),.rst(rst))={
        START, //wait for start button
        GENERATE_MAP, //map -> idle
        IDLE,
        CHECK_BORDER,
        CHECK_GOAL, //check whether reached goal
        CHECK_COLL, //check obstacle
        GAMEOVER,
        WIN};
  

  always {

    //connection
    x_temp.d = x_pos_in;
    y_temp.d = y_pos_in;
    x_pos_out = x_temp.q;
    y_pos_out = y_temp.q;
    level_temp.d = level_in;
    level_out = level_temp.q;

    //check timer
    if (timer > 60){ctrl.d = ctrl.GAMEOVER;}//exceed time

    //fms ctrl
    case(ctrl.q){

        ctrl.START:
            if (start == 1){ctrl.d = ctrl.GENERATE_MAP;}
            else{ctrl.d = ctrl.START;}
     
        //////////////////////////////
        ctrl.GENERATE_MAP:
            case(level_in){
            0: 
            //generate map 0

            1:
            //generate map 1

            2:
            //generate map 2


            }
            ctrl.d = ctrl.IDLE;
        //////////////////////////////
        ctrl.IDLE:
            if (direction[0]==1 || direction[1]==1 || direction[2]==1 || direction[3]==1){
                //change position temp
                case(direction){
                    b1000: y_temp.d = y_temp.q + 1;//up
                    b0100: y_temp.d = y_temp.q - 1;//down
                    b0010: x_temp.d = x_temp.q + 1;//right
                    b0001: x_temp.d = x_temp.q - 1;//left
                }
                ctrl.d = ctrl.CHECK_GOAL;
            }
            else{ctrl.d = ctrl.IDLE;}
        //////////////////////////////
        ctrl.CHECK_GOAL:
            if (x_temp.q == b111 && y_temp.q == b111){
                ctrl.d = ctrl.WIN;
                }
            else {ctrl.d = ctrl.CHECK_BORDER;}

        //////////////////////////////
        ctrl.CHECK_BORDER:
            if (x_temp.q>b111 || x_temp.q <b00 || y_temp.q>b111 || y_temp.q<b000){
                ctrl.d = ctrl.IDLE;
            }
            else{ctrl.d = ctrl.CHECK_COLL;}
        //////////////////////////////
        ctrl.CHECK_COLL:
            if (map[x_temp.q][y_temp.q]==1){
                ctrl.d = ctrl.IDLE;
            }
            else{
                //write position from temp dff
                x_pos_out = x_temp.q;
                y_pos_out = y_temp.q;
                ctrl.d = ctrl.IDLE; 
        }
        //////////////////////////////
        ctrl.WIN:
            if (level_in < b10 && level_in >= b00){
                level_out = level_in + 1;
                ctrl.d = ctrl.START;
            }
            else {ctrl.d = ctrl.GAMEOVER;}
        //////////////////////////////
        ctrl.GAMEOVER:
        if (reset == 1){
            level_out = 0;
            ctrl.d=ctrl.START;
            }
        else{
            //show 7-seg msg
            ctrl.d = ctrl.GAMEOVER;}

        

    }
  }
}






