module ROM_regfile_test_case (
    input address[5],  // ROM address

    output ra[5],
    output rb[5],
    output rc[5],
    output we,
    output write_data[16],
    output level_in[2],
    output in_time[16],

    output level_out[2],
    output out_time[16], // supposed correct outputs of regfile
    output XPos[3],
    output YPos[3],
    output ra_data[16],
    output rb_data[16];
    output map[8][8];

  ) {
 
  // 5 testcases in the format of  FIXME: add 3 more test cases since autochecker implements 5 test cases
  // ra, rb, rc we, write_data, level_in, in_time, level_out, out_time, XPos, YPos, ra_data, rb_data, map
  const TESTCASES_regfile =      
  { 
    {5h0, 5h1, 5hb, 1b1, 16b0001000100000001, 2b00, 16b0, 2b00, 16b0, 3b000, 3b000, {0, 0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0},  // ra returns map row 1, rb returns map row 2, rc write to a temp reg 
        {
          {0, 0, 0, 0, 0, 1, 0, 0},              // level 1 map row 1
          {0, 0, 0, 1, 0, 1, 0, 0},              // level 1 map row 2
          {1, 0, 0, 0, 0, 0, 0, 1},              // level 1 map row 3
          {0, 0, 0, 1, 0, 1, 0, 0},              // level 1 map row 4
          {0, 0, 1, 1, 0, 0, 1, 0},              // level 1 map row 5
          {1, 0, 0, 0, 0, 0, 0, 0},              // level 1 map row 6
          {0, 0, 1, 0, 0, 1, 0, 0},              // level 1 map row 7
          {0, 0, 0, 0, 0, 0, 0, 0},              // level 1 map row 8
        }
    }, // TEST: level 1 is 2b00, we=1, timer is less than 60, panda (0,0), test if correct map comes out
    // FIXME: should the out time be the same as the in time for the regfile? actually we might not evenn need to test it. currently test case says in_time = out_time

    {5h0, 5h1, 5hb, 1b1, 16b0001000100000001, 2b01, 16b0, 2b01, 16b0, 3b000, 3b000, {0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 0, 0, 0},  
        {
          {0, 0, 1, 0, 0, 0, 0, 0},              // level 2 map row 1
          {0, 0, 0, 1, 1, 0, 0, 0},              // level 2 map row 2
          {1, 0, 0, 1, 0, 0, 1, 0},              // level 2 map row 3
          {1, 0, 0, 0, 0, 0, 0, 0},              // level 2 map row 4
          {0, 1, 0, 0, 0, 1, 1, 0},              // level 2 map row 5
          {0, 1, 0, 0, 1, 1, 0, 0},              // level 2 map row 6
          {0, 0, 0, 0, 0, 0, 0, 0},              // level 2 map row 7
          {0, 0, 1, 0, 0, 0, 0, 0},              // level 2 map row 8
        }
    }, // TEST: level 2 is 2b01, we=1, level 2 map should generate 



  };

  always {
    // correct_out_time = TESTCASES_regfile[address][5]; //NOTE: indexing order in array in lucid: 0 starts from right
    ra = TESTCASES_regfile[address][13];
    rb = TESTCASES_regfile[address][12];
    rc = TESTCASES_regfile[address][11];
    we = TESTCASES_regfile[address][10];
    write_data = TESTCASES_regfile[address][9];
    level_in = TESTCASES_regfile[address][8];
    in_time = TESTCASES_regfile[address][7];

    level_out = TESTCASES_regfile[address][6];
    out_time = TESTCASES_regfile[address][5];
    XPos = TESTCASES_regfile[address][4];
    YPos = TESTCASES_regfile[address][3];
    ra_data = TESTCASES_regfile[address][2];
    rb_data = TESTCASES_regfile[address][1];
    map = TESTCASES_regfile[address][0];
  }
}

// 6 hex digits
// 1 byte is 8 binary bits
// 1 byte is 2 hex digits
// 1 hex digit is 4 binary bits