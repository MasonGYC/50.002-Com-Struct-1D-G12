module rom_regfile_test_case (
    input address[5],  // ROM address

    output in_time[16],
    output x_pos_in[3],
    output y_pos_in[3],
    output we,
    output write_data[16],
    output level_in[2],

    output level_out[2],
    output out_time[16], // supposed correct outputs of regfile
    output XPos[3],
    output YPos[3],
    output map[8][8];
    // output correct_ra_data,
    // output correct_rb_data;

  ) {
 
  // 5 testcases in the format of  FIXME: add 3 more test cases since autochecker implements 5 test cases
  // in_time x_pos_in y_pos_in we write_data[16] level_in correct_level_out correct_out_time[16] correct_XPos correct_YPos correct_map
  const TESTCASES_regfile =      
  { 
    {16b01, 3b000, 3b000, 1b1, 16b0001000100000001, 2b00, 2b00, 16b01, 3b000, 3b000, 
        {
          {0, 0, 0, 0, 0, 1, 0, 0},              // level 1 map row 1
          {0, 0, 0, 1, 0, 1, 1, 0},              // level 1 map row 2
          {1, 0, 0, 0, 0, 0, 0, 1},              // level 1 map row 3
          {0, 0, 0, 1, 0, 1, 0, 0},              // level 1 map row 4
          {0, 0, 1, 1, 0, 0, 1, 0},              // level 1 map row 5
          {1, 0, 0, 0, 0, 0, 0, 0},              // level 1 map row 6
          {0, 0, 1, 0, 0, 1, 0, 0},              // level 1 map row 7
          {0, 0, 0, 0, 0, 0, 0, 0},              // level 1 map row 8
        }
    }, // TEST: level 1 is 2b00, we=1, timer is less than 60, panda (0,0), test if correct map comes out
    // FIXME: should the out time be the same as the in time for the regfile? actually we might not evenn need to test it. currently test case says in_time = out_time

    {16b10, 3b001, 3b001, 1b1, 16b0001000100000001, 2b01, 2b01, 16b10, 3b001, 3b001, 
        {
          {0, 0, 1, 0, 0, 0, 0, 0},              // level 2 map row 1
          {0, 0, 0, 1, 1, 0, 0, 0},              // level 2 map row 2
          {1, 0, 0, 1, 0, 0, 1, 0},              // level 2 map row 3
          {1, 0, 0, 0, 0, 0, 0, 0},              // level 2 map row 4
          {0, 1, 0, 0, 0, 1, 1, 0},              // level 2 map row 5
          {0, 1, 0, 0, 1, 1, 0, 0},              // level 2 map row 6
          {0, 0, 0, 0, 0, 0, 0, 0},              // level 2 map row 7
          {0, 0, 1, 0, 0, 0, 0, 0},              // level 2 map row 8
        }
    }, // TEST: level 2 is 2b01, we=1, level 2 map should generate 



  };

  always {
    // correct_out_time = TESTCASES_regfile[address][5]; //NOTE: indexing order in array in lucid: 0 starts from right
    in_time = TESTCASES_regfile[address][10];
    x_pos_in = TESTCASES_regfile[address][9];
    y_pos_in = TESTCASES_regfile[address][8];
    we = TESTCASES_regfile[address][7];
    write_data = TESTCASES_regfile[address][6];
    level_in = TESTCASES_regfile[address][5];

    level_out = TESTCASES_regfile[address][4];
    out_time = TESTCASES_regfile[address][3];
    XPos = TESTCASES_regfile[address][2];
    YPos = TESTCASES_regfile[address][1];
    map = TESTCASES_regfile[address][0];
  }
}

// 6 hex digits
// 1 byte is 8 binary bits
// 1 byte is 2 hex digits
// 1 hex digit is 4 binary bits