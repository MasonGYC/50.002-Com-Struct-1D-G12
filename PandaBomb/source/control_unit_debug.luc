module control_unit (
    //this version uses ALU
    //add in debug signal for testing
    input clk,  // clock
    input rst,  // reset
    input z, // alu z
    input level_in[16],//level_in
    output level_out[16],
    input direction[4], //up down LEFT RIGHT,
    input start[1], //START button
    input reset[1], //RESET button
    input timer[16],
    output alufn[6],
    output asel[4],
    output bsel[4],
    output we[1],
    output wdsel[2],
    output ra[5],
    output rb[5],
    output rc[5],
    output game_start[1],
    output seg_index[4][4] //debug seven_seg
    
    
    
  ) {
  // 5hD: temp[2] y temp always
  // 5hE: temp[3] x temp always
  const X_TEMP = 5hE;
  const Y_TEMP = 5hD;
  const RANDOM = 5hA;
  const X_POS = 5h8;
  const Y_POS = 5h9;
  
  counter slowclock(#SIZE(1),#DIV(26),.clk(clk),.rst(rst));
  fsm ctrl(.clk(slowclock.value),.rst(rst))={
    START, //wait for start button
    IDLE,
    CHECKUPBORDER,GOUP,CHECKDOWNBORDER,GODOWN,CHECKLEFTBORDER,GOLEFT,CHECKRIGHTBORDER,GORIGHT,
    CHECK_GOAL_X, CHECK_GOAL_Y,CHECK_GOAL_XY,CHECK_GOAL_XY_MOVE, //check whether reached goal
    CHECK_COLL,CHECK_COLL_INDEX, //check obstacle
    UPDATE_XPOS,UPDATE_YPOS,
    CHECK_WIN_UPPERBOUND,CHECK_WIN_LOWERBOUND,CHECK_WIN_AND,CHECK_WIN_LEVELUP,CHECK_WIN_LEVELUP_CHECK,
    GAMEOVER,RESET_LEVEL};
  
  
  always {
    
    //connection
    alufn = 6b0; //add
    we = b0;
    asel = 4b0;//ra
    bsel = 4b0; //rb
    wdsel = 3b0;//alu
    ra = 5h13; //temp7
    rb = 5h13;
    rc = 5h13;
    level_out = 16b0;
    game_start = b0;
    seg_index = {4h0,4h0,4h0,4h0};
    
    //check timer
    if (timer > 16b111100){
      ctrl.d = ctrl.GAMEOVER;
    }//exceed time 60 sec
    
    //fms ctrl
    case(ctrl.q){
      
      ctrl.START:
        seg_index = {4h0,4h0,4h0,4h0};
        if (start == b1){
          ctrl.d = ctrl.IDLE;}
        else{
          ctrl.d = ctrl.START;}

      //////////////////////////////
      ctrl.IDLE:
        seg_index = {4h8,4h8,4h8,4h8};
        if (direction[0]==b1 || direction[1]==b1 || direction[2]==b1 || direction[3]==b1){
          //check direction and current x y border
          case(direction){
            b1000:
            ctrl.d = ctrl.CHECKUPBORDER;
              //Y_TEMP.d = Y_TEMP.q + 1;//up
              //if (y==b111){ctrl.d = ctrl.IDLE;}
            b0100:
            ctrl.d = ctrl.CHECKDOWNBORDER;
              // Y_TEMP.d = Y_TEMP.q - 1;//down
              //if (y==b0){ctrl.d = ctrl.IDLE;}
            b0010:
            ctrl.d = ctrl.CHECKLEFTBORDER;
              //X_TEMP.d = X_TEMP.q - 1;//LEFT
              //if (x==b0){ctrl.d = ctrl.IDLE;}
            b0001:
            ctrl.d = ctrl.CHECKRIGHTBORDER;
              // X_TEMP.d = X_TEMP.q + 1;//RIGHT
              //if (x==b111){ctrl.d = ctrl.IDLE;}
          }
          
        }
        else{ctrl.d = ctrl.IDLE;}

      //////////////////////////////
    ctrl.CHECKUPBORDER:
    seg_index = {4h0,4h0,4h0,4h1};
        //if (y==b111){ctrl.d = ctrl.IDLE;}
        ra = Y_POS; // x temp reg
        rb = RANDOM; // RANDOM num
        rc = 5hB; // result 1/0
        asel = 4b0; // choose ra data
        bsel = 4b0111; // choose 7
        alufn = 6b110011; // equal
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.CHECKUPBORDER_CMP;
    //    
    ctrl.CHECKUPBORDER_CMP:
        //if 5hB == 1, when add 0, res = 1, z=0, means equal, means idle
        seg_index = {4h1,4h0,4h0,4h1};
        ra = 5hB; // compare result
        rb = RANDOM; // RANDOM num
        rc = 5hC; // random
        asel = 4b0; // choose ra data
        bsel = 4b1010; // choose 0
        alufn = 6b0; // add
        we = b0; // write not enable
        wdsel = 3b0; //take alu output

        if (z==0){
            ctrl.d = ctrl.IDLE;}
        else{ctrl.d = ctrl.GOUP;}

    ctrl.GOUP:
    seg_index = {4h0,4h0,4h0,4h2};
     //Y_TEMP.d = Y_TEMP.q + 1;
        ra = Y_POS; // Y_POS reg
        rb = RANDOM; // RANDOM num
        rc = Y_TEMP; // y temp
        asel = 4b0; // choose ra data
        bsel = 4b1; // choose 1
        alufn = 6b0; // add
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.CHECK_GOAL_X;

    //////////////////////////////

    ctrl.CHECKDOWNBORDER:
    seg_index = {4h0,4h0,4h0,4h3};
        //if (y==b0){ctrl.d = ctrl.IDLE;}
        ra = Y_POS; // x temp reg
        rb = RANDOM; // RANDOM num
        rc = 5hB; // result 1/0
        asel = 4b0; // choose ra data
        bsel = 4b1010; // choose 0
        alufn = 6b110011; // equal
        we = b0; // write not enable
        wdsel = 3b0; //take alu output
        if (z==0){//res = 1
            ctrl.d = ctrl.IDLE;}
        else{ctrl.d = ctrl.GODOWN;}
    
    ctrl.GODOWN:
    seg_index = {4h0,4h0,4h0,4h4};
     //Y_TEMP.d = Y_TEMP.q - 1;
        ra = Y_POS; // Y_POS reg
        rb = RANDOM; // RANDOM num
        rc = Y_TEMP; // y temp
        asel = 4b0; // choose ra data
        bsel = 4b1; // choose 1
        alufn = 6b1; // subc
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.CHECK_GOAL_X;

    //////////////////////////////
    ctrl.CHECKLEFTBORDER:
    seg_index = {4h0,4h0,4h0,4h5};
        //if (x==b0){ctrl.d = ctrl.IDLE;}
        ra = X_POS; // x POS reg
        rb = RANDOM; // RANDOM num
        rc = 5hB; // result 1/0
        asel = 4b0; // choose ra data
        bsel = 4b1010; // choose 0
        alufn = 6b110011; // equal
        we = b0; // write not enable
        wdsel = 3b0; //take alu output
        if (z==0){//res = 1
            ctrl.d = ctrl.IDLE;}
        else{ctrl.d = ctrl.GOLEFT;}

    ctrl.GOLEFT:
    seg_index = {4h0,4h0,4h0,4h6};
    //X_TEMP.d = X_TEMP.q - 1;//LEFT
        ra = X_POS; // x POS reg
        rb = RANDOM; // RANDOM num
        rc = X_TEMP; // x temp
        asel = 4b0; // choose ra data
        bsel = 4b1; // choose 1
        alufn = 6b1; // subc
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.CHECK_GOAL_X;


    //////////////////////////////
    ctrl.CHECKRIGHTBORDER:
    seg_index = {4h0,4h0,4h0,4h7};
        //if (x==b111){ctrl.d = ctrl.IDLE;}
        ra = X_POS; // x POS reg
        rb = RANDOM; // RANDOM num
        rc = 5hB; // result 1/0
        asel = 4b0; // choose ra data
        bsel = 4b0111; // choose 7
        alufn = 6b110011; // equal
        we = b0; // write not enable
        wdsel = 3b0; //take alu output
        if (z==0){//res = 1
            ctrl.d = ctrl.IDLE;}
        else{ctrl.d = ctrl.GORIGHT;}

    ctrl.GORIGHT:
    seg_index = {4h0,4h0,4h0,4h8};
        // X_TEMP.d = X_TEMP.q + 1;//RIGHT
      ra = X_POS; // x PSOS reg
      rb = RANDOM; // RANDOM num
      rc = X_TEMP; // x temp
      asel = 4b0; // choose ra data
      bsel = 4b1; // choose 1
      alufn = 6b0; // add
      we = b1; // write enable
      wdsel = 3b0; //take alu output

      //////////////////////////////
      ctrl.CHECK_GOAL_X:
        seg_index = {4h0,4h0,4h0,4h9};
        //if X_TEMP.q == b111: check Y_TEMP
        ra = X_TEMP; // x temp reg
        rb = RANDOM; // RANDOM num
        rc = 5hC; // result 1/0
        asel = 4b0; // choose ra data
        bsel = 4b0111; // choose 7
        alufn = 6b110011; // equal
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.CHECK_GOAL_Y;
      ctrl.CHECK_GOAL_Y:
        seg_index = {4h0,4h0,4h1,4h0};
        //if Y_TEMP.q == b111)
        ra = Y_TEMP; // y temp reg
        rb = RANDOM; // RANDOM num
        rc = 5hB; // result 1/0
        asel = 4b0; // choose ra data
        bsel = 4b0111; // choose 7
        alufn = 6b110011; // equal
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.CHECK_GOAL_XY;
      ctrl.CHECK_GOAL_XY:
        //if x && y
        seg_index = {4h0,4h0,4h1,4h1};
        ra = 5hB; // x=7
        rb = 5hC; // y=7
        rc = 5h10; // result 1/0
        asel = 4b0; // choose ra data
        bsel = 4b0; // choose rb data
        alufn = 6b011000; // and
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.CHECK_GOAL_XY_MOVE;
      ctrl.CHECK_GOAL_XY_MOVE:
        seg_index = {4h0,4h0,4h1,4h2};
        if (z == 0){ //res = 1, satisfy both
          ctrl.d = ctrl.CHECK_WIN_UPPERBOUND; // both x and y == 7
        }
        else {ctrl.d = ctrl.CHECK_COLL;}
      
      //////////////////////////////
      ctrl.CHECK_COLL:
        seg_index = {4h0,4h0,4h1,4h3};
        ra = RANDOM; // random
        rb = X_TEMP; // x_TEMP
        rc = 5hC; // shifted slicing index
        asel = 4b1; // 1
        bsel = 4b0; // choose rb data
        alufn = 6b100000; // shl
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.CHECK_COLL_INDEX;
      ctrl.CHECK_COLL_INDEX:
        seg_index = {4h0,4h0,4h1,4h4};
        ra = Y_TEMP[4:0]; // Y_TEMP
        rb = 5hC; // shifted one hot
        rc = 5hD; // shifted slicing index
        asel = 4b0; // choose ra data
        bsel = 4b0; // choose rb data
        alufn = 6b011000; // and
        we = b0; // write not enable
        wdsel = 3b0; //take alu output
        if (z==b0){
          ctrl.d = ctrl.IDLE;
        }
        else{
          //write position from temp dff
          // x_pos_out = X_TEMP.q;
          // y_pos_out = Y_TEMP.q;
          // ctrl.d = ctrl.IDLE;
          ctrl.d = ctrl.UPDATE_XPOS;
        }
      //////////////////////////////
      ctrl.UPDATE_XPOS:
        seg_index = {4h0,4h0,4h1,4h5};
        // x_pos_out = X_TEMP.q;
        ra = X_TEMP; // x temp
        rb = RANDOM; // ran
        rc = 5h8; // x coor
        asel = 4b0; // choose ra data
        bsel = b1010; // 0
        alufn = 6b0; // add
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.UPDATE_YPOS;
      //////////////////////////////
      ctrl.UPDATE_YPOS:
        seg_index = {4h0,4h0,4h1,4h6};
        // y_pos_out = Y_TEMP.q;
        ra = Y_TEMP; // y temp
        rb = RANDOM; // ran
        rc = 5h9; // y coor
        asel = 4b0; // choose ra data
        bsel = b1010; // 0
        alufn = 6b0; // add
        we = b1; // write enable
        wdsel = 3b0; //take alu output
        ctrl.d = ctrl.IDLE;
      //////////////////////////////
      ctrl.CHECK_WIN_UPPERBOUND:
        seg_index = {4h0,4h0,4h1,4h7};
        if (level_in < b10 && level_in >= b00){
          level_out = level_in + b1;
          ctrl.d = ctrl.START;
        }
        else {ctrl.d = ctrl.GAMEOVER;}
      //////////////////////////////
      ctrl.GAMEOVER:
        seg_index = {4h7,4h7,4h7,4h7};
        if (reset == b1){
          ctrl.d = ctrl.RESET_LEVEL;}
        else{
          //show 7-seg msg
          ctrl.d = ctrl.GAMEOVER;}
      //////////////////////////////
      ctrl.RESET_LEVEL:
        seg_index = {4h6,4h6,4h6,4h6};
        level_out = 16b0;
        ctrl.d = ctrl.START;
      
    }
  }
}