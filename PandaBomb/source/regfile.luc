module regfile (
    input clk,  // clock
    input rst,  // reset
    input in_time[16],
    // input ra[4],
    // input rb[4],
    // input rc[4],
    input x_pos_in[3],
    input y_pos_in[3],
    input we,
    input write_data[16],
    input level_in[2],

    output level_out[2],
    output out_time[16], // output time to 7 segment 16 bits
    output XPos[3],
    output YPos[3], // 3bit binary number to represent value of y coordinate from 0 - 7
    output map[8][8];
    // output ra_data[16], 
    // output rb_data[16],
    
  ) {

  dff reg_map_row1[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 1 of the map
  dff reg_map_row2[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 2 of the map
  dff reg_map_row3[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 3 of the map
  dff reg_map_row4[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 4 of the map
  dff reg_map_row5[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 5 of the map
  dff reg_map_row6[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 6 of the map
  dff reg_map_row7[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 7 of the map
  dff reg_map_row8[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 8 of the map
  dff reg_Xpos[3](.clk(clk), .rst(rst));        // 3-bit binary number to represent value of x coordinate from 0 - 7
  dff reg_Ypos[3](.clk(clk), .rst(rst));        // 3-bit binary number to represent value of y coordinate from 0 - 7
  dff reg_time[16](.clk(clk), .rst(rst));       // 16-bit binary number to represent time in seconds
  // dff reg_temp[3][16](.clk(clk), .rst(rst));    // 3 temporary 16-bit registers in case we need to do something with it
  dff reg_level[2](.clk(clk), .rst(rst));       // 1: level1, 2: level2, 3: level3 (2bit binary number)
  
  always {
    
    // ra_data = 16h0000;
    // rb_data = 16h0000;
    maps r;
    
    if (we) {
        r.level_input = reg_level.q // tell ROM that level is _?_ stored in dff reg_level.q ROM should have case functionality that takes in level and give out the corresponding map rows of that level

        reg_map_row1.d = r.out_row1;
        reg_map_row2.d = r.out_row2;
        reg_map_row3.d = r.out_row3;
        reg_map_row4.d = r.out_row4;
        reg_map_row5.d = r.out_row5;
        reg_map_row6.d = r.out_row6;
        reg_map_row7.d = r.out_row7;
        reg_map_row8.d = r.out_row8;
        reg_Xpos.d = x_pos_in; // 4h00 is the address of rc. thus when rc is 4h00, that particular line will be overwritten with a new write_data
        reg_Ypos.d = y_pos_in;
        reg_time.d = in_time;
        // reg_temp.d[0] = write_data; // if we ever need to use temp registers
        // reg_temp.d[1] = write_data;
        // reg_temp.d[2] = write_data;
        reg_level.d = input_level;
    }

    out_time = reg_time.q; 
    XPos = reg_Xpos.q;
    YPos = reg_Ypos.q;
    map = r.full_map;
    reg_level.d = level_in; // put level input into dff reg
    
  }
}