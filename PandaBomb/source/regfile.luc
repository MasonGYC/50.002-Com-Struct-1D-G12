module regfile ( // FIXME: KIV might change whole structure of regfile
    input clk,  // clock
    input rst,  // reset
    input ra[4],
    input rb[4],
    input rc[4],
    input we,
    input write_data[16],
    input level, // FIXME: think we need a level input? to tell the rom which level to laod. unless we dont need to load the map into the regfile but im assuming we do
    output out_time[16], // output time to 7 segment 16 bits
    output XPos, // FIXME: x position will be denoted by the full 8 bit binary right? eg. 00001000 or will it be x coordinate 5?
    output YPos, // 3bit binary number to represent value of y coordinate from 0 - 7
    output ra_data[16],
    output rb_data[16],
    output map;
  ) {

  dff reg_map_row1[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 1 of the map
  dff reg_map_row2[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 2 of the map
  dff reg_map_row3[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 3 of the map
  dff reg_map_row4[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 4 of the map
  dff reg_map_row5[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 5 of the map
  dff reg_map_row6[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 6 of the map
  dff reg_map_row7[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 7 of the map
  dff reg_map_row8[8](.clk(clk), .rst(rst));    // 8-bit binary number to represent row 8 of the map
  dff reg_Xpos[3](.clk(clk), .rst(rst));        // 3-bit binary number to represent value of x coordinate from 0 - 7
  dff reg_Ypos[3](.clk(clk), .rst(rst));        // 3-bit binary number to represent value of y coordinate from 0 - 7
  dff reg_time[16](.clk(clk), .rst(rst));       // 16-bit binary number to represent time in seconds
  dff reg_temp[4][16](.clk(clk), .rst(rst));    // 3 temporary 16-bit registers in case we need to do something with it
  dff reg_level[2](.clk(clk), .rst(rst));       // 1: level1, 2: level2, 3: level3 (2bit binary number)
  
  always {
    
    ra_data = 16h0000;
    rb_data = 16h0000;
    ROM_map r;
    
    if (we) { // FIXME: I realise that Control Unit never gives out these Signals 'alufn', asel, bsel, wdsel, we, werf, if we are not using them, how shall we implement a regfile software style?
      case (rc) {
        r.level_input = reg_level.q // tell ROM that level is _?_ stored in dff reg_level.q ROM should have case functionality that takes in level and give out the corresponding map rows of that level

        4h0: reg_map_row1.d = r.out_row1;
        4h1: reg_map_row2.d = r.out_row2;
        4h2: reg_map_row3.d = r.out_row3;
        4h3: reg_map_row4.d = r.out_row4;
        4h4: reg_map_row5.d = r.out_row5;
        4h5: reg_map_row6.d = r.out_row6;
        4h6: reg_map_row7.d = r.out_row7;
        4h7: reg_map_row8.d = r.out_row8;
        4h8: reg_Xpos.d = write_data[2:0]; // 4h00 is the address of rc. thus when rc is 4h00, that particular line will be overwritten with a new write_data
        4h9: reg_Ypos.d = write_data[2:0];
        4hA: reg_time.d = write_data[16:0];
        4hB: reg_temp.d[0] = write_data;
        4hC: reg_temp.d[1] = write_data;
        4hD: reg_temp.d[2] = write_data;
        4hE: reg_level.d = input_level;
      }
    }
    
    case (ra) {
      4h0: ra_data[8:0] = reg_map_row1.q; //FIXME: question are we even going to use the ra rb rc stuff? lol seems like we dont need
      4h1: ra_data[8:0] = reg_map_row2.q;
      4h2: ra_data[8:0] = reg_map_row3.q;
      4h3: ra_data[8:0] = reg_map_row4.q;
      4h4: ra_data[8:0] = reg_map_row5.q;
      4h5: ra_data[8:0] = reg_map_row6.q;
      4h6: ra_data[8:0] = reg_map_row7.q;
      4h7: ra_data[8:0] = reg_map_row8.q;
      4h8: ra_data[8:0] = reg_Xpos.q;
      4h9: ra_data[2:0] = reg_Ypos.q;
      4hA: ra_data[16:0] = reg_time.q;
      4hB: ra_data = reg_temp.q[0];
      4hC: ra_data = reg_temp.q[1];
      4hD: ra_data = reg_temp.q[2];
      4hE: ra_data = reg_level.q;
    }
    
    case (rb) {
      4h0: rb_data[8:0] = reg_map_row1.q;
      4h1: rb_data[8:0] = reg_map_row2.q;
      4h2: rb_data[8:0] = reg_map_row3.q;
      4h3: rb_data[8:0] = reg_map_row4.q;
      4h4: rb_data[8:0] = reg_map_row5.q;
      4h5: rb_data[8:0] = reg_map_row6.q;
      4h6: rb_data[8:0] = reg_map_row7.q;
      4h7: rb_data[8:0] = reg_map_row8.q;
      4h8: rb_data[8:0] = reg_Xpos.q;
      4h9: rb_data[2:0] = reg_Ypos.q;
      4hA: rb_data[16:0] = reg_time.q;
      4hB: rb_data = reg_temp.q[0];
      4hC: rb_data = reg_temp.q[1];
      4hD: rb_data = reg_temp.q[2];
      4hE: rb_data = reg_level.q;
    }

    out_time = reg_time.q; 
    XPos = reg_Xpos.q;
    YPos = reg_Ypos.q;
    map = r.full_map
    level = reg_level.q // put level input into dff reg
  }
}