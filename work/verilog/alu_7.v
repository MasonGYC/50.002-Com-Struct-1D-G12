/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module alu_7 (
    input [5:0] alufn,
    input [15:0] a,
    input [15:0] b,
    output reg [15:0] out,
    output reg z,
    output reg v,
    output reg n,
    output reg ex
  );
  
  
  
  wire [16-1:0] M_adder_s;
  wire [1-1:0] M_adder_z;
  wire [1-1:0] M_adder_v;
  wire [1-1:0] M_adder_n;
  reg [16-1:0] M_adder_a;
  reg [16-1:0] M_adder_b;
  reg [6-1:0] M_adder_alufn;
  adder2_14 adder (
    .a(M_adder_a),
    .b(M_adder_b),
    .alufn(M_adder_alufn),
    .s(M_adder_s),
    .z(M_adder_z),
    .v(M_adder_v),
    .n(M_adder_n)
  );
  
  wire [16-1:0] M_boolean_alu;
  reg [16-1:0] M_boolean_a;
  reg [16-1:0] M_boolean_b;
  reg [4-1:0] M_boolean_alufn;
  bool2_15 boolean (
    .a(M_boolean_a),
    .b(M_boolean_b),
    .alufn(M_boolean_alufn),
    .alu(M_boolean_alu)
  );
  
  wire [16-1:0] M_shift_shift;
  reg [16-1:0] M_shift_a;
  reg [4-1:0] M_shift_b;
  reg [2-1:0] M_shift_alufn;
  shifter_16 shift (
    .a(M_shift_a),
    .b(M_shift_b),
    .alufn(M_shift_alufn),
    .shift(M_shift_shift)
  );
  
  wire [1-1:0] M_comparator_out;
  reg [1-1:0] M_comparator_z;
  reg [1-1:0] M_comparator_v;
  reg [1-1:0] M_comparator_n;
  reg [6-1:0] M_comparator_alufn;
  compare_17 comparator (
    .z(M_comparator_z),
    .v(M_comparator_v),
    .n(M_comparator_n),
    .alufn(M_comparator_alufn),
    .out(M_comparator_out)
  );
  
  wire [16-1:0] M_mul_out;
  reg [16-1:0] M_mul_a;
  reg [16-1:0] M_mul_b;
  multiply_18 mul (
    .a(M_mul_a),
    .b(M_mul_b),
    .out(M_mul_out)
  );
  
  wire [16-1:0] M_div_q;
  wire [16-1:0] M_div_r;
  wire [1-1:0] M_div_ex;
  reg [16-1:0] M_div_a;
  reg [16-1:0] M_div_b;
  divide2_19 div (
    .a(M_div_a),
    .b(M_div_b),
    .q(M_div_q),
    .r(M_div_r),
    .ex(M_div_ex)
  );
  
  wire [16-1:0] M_com_n;
  reg [16-1:0] M_com_a;
  sixteen_bit_2s_complement_20 com (
    .a(M_com_a),
    .n(M_com_n)
  );
  
  always @* begin
    M_adder_a = a;
    M_adder_b = b;
    M_adder_alufn = alufn;
    z = M_adder_z;
    v = M_adder_v;
    n = M_adder_n;
    M_boolean_a = a;
    M_boolean_b = b;
    M_boolean_alufn = alufn[0+3-:4];
    M_shift_a = a;
    M_shift_b = b[0+3-:4];
    M_shift_alufn = alufn[0+1-:2];
    M_comparator_z = M_adder_z;
    M_comparator_v = M_adder_v;
    M_comparator_n = M_adder_n;
    M_comparator_alufn = alufn;
    M_mul_a = a;
    M_mul_b = b;
    out = M_mul_out;
    M_div_a = a;
    M_div_b = b;
    ex = 1'h0;
    M_com_a = a;
    out = 16'h0000;
    if (alufn == 6'h00 | alufn == 6'h01) begin
      out = M_adder_s;
    end else begin
      if (alufn == 6'h1e | alufn == 6'h16 | alufn == 6'h1a | alufn == 6'h18) begin
        out = M_boolean_alu;
      end else begin
        if (alufn == 6'h20 | alufn == 6'h21 | alufn == 6'h23) begin
          out = M_shift_shift;
        end else begin
          if (alufn == 6'h33 | alufn == 6'h35 | alufn == 6'h37) begin
            out = M_comparator_out;
          end else begin
            if (alufn == 6'h02) begin
              out = M_mul_out;
            end else begin
              if (alufn == 6'h03) begin
                out = M_div_q;
                ex = M_div_ex;
              end else begin
                if (alufn == 6'h04) begin
                  out = M_div_r;
                  ex = M_div_ex;
                end else begin
                  if (alufn == 6'h05) begin
                    out = M_com_n;
                  end
                end
              end
            end
          end
        end
      end
    end
  end
endmodule
